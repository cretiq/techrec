# Bug Prevention & Resolution for AI Development

## ğŸš¨ CRITICAL: BEFORE implementing any feature

1. **Search the bug database FIRST**: [bug-reporting-resolution.md](mdc:docs/implementation/bug-reporting-resolution.md)
2. **Use search tags** to find similar patterns: #redux-loading #api-undefined #type-mismatch #hydration-error
3. **Follow established patterns** from resolved bugs instead of recreating solutions
4. **Copy working code patterns** directly from the bug database

## ğŸ” WHEN encountering bugs

1. **Search tags first** using symptoms/error messages in [bug-reporting-resolution.md](mdc:docs/implementation/bug-reporting-resolution.md)
2. **If found**: Follow the exact resolution pattern provided
3. **If not found**: Document new bug using the template in the bug database
4. **Always update prevention checklist** with new learnings

## âš¡ Common AI Mistakes to ALWAYS Avoid

### Redux State Management
- **âŒ NEVER forget**: `state.status = 'succeeded'` in fulfilled cases
- **âŒ NEVER skip**: REHYDRATE action handling when using Redux persist
- **âŒ NEVER assume**: Data exists without null checks
- **âœ… ALWAYS include**: All three async cases (pending/fulfilled/rejected)

### API Integration
- **âŒ NEVER assume**: API response structure matches frontend expectations
- **âŒ NEVER skip**: Input validation with Zod schemas
- **âŒ NEVER forget**: Error handling for all endpoints
- **âœ… ALWAYS validate**: Request and response data

### Database Operations
- **âŒ NEVER create**: N+1 queries (use includes instead)
- **âŒ NEVER skip**: Proper error handling
- **âŒ NEVER assume**: Relations will load automatically
- **âœ… ALWAYS use**: Single queries with includes for related data

### UI Components
- **âŒ NEVER render**: Without null/undefined checks
- **âŒ NEVER skip**: Loading states
- **âŒ NEVER assume**: Props will always exist
- **âœ… ALWAYS check**: Data existence before mapping or accessing

## ğŸ¯ Quick Resolution Patterns

### "Loading forever" â†’ Check Redux status updates
```typescript
// âœ… ALWAYS include status updates
.addCase(fetchData.fulfilled, (state, action) => {
  state.data = action.payload;
  state.status = 'succeeded';  // â† AI frequently forgets this
})
```

### "Cannot read property 'map'" â†’ Add null checks
```typescript
// âœ… ALWAYS check data exists
if (!roles || roles.length === 0) return <EmptyState />;
return roles.map(role => <RoleCard key={role.id} role={role} />);
```

### "Hydration mismatch" â†’ Handle REHYDRATE
```typescript
// âœ… ALWAYS handle REHYDRATE
.addCase(REHYDRATE, (state, action: any) => {
  if (action.payload?.slice && state.data && state.status === 'idle') {
    state.status = 'succeeded';
  }
})
```

### "Slow database queries" â†’ Use includes
```typescript
// âœ… Single query with includes
const rolesWithSkills = await prisma.role.findMany({
  include: { skills: true }
});
```

## ğŸ“‹ Prevention Checklists

### Before Redux Implementation
- [ ] All async cases update status (pending/fulfilled/rejected)
- [ ] REHYDRATE case handles status properly
- [ ] Persist config includes all necessary fields
- [ ] Component checks status before rendering data

### Before API Implementation
- [ ] Request/response types defined
- [ ] Input validation with Zod schemas
- [ ] Error handling for all endpoints
- [ ] Response transformation when needed

### Before Database Operations
- [ ] Use includes for related data
- [ ] Avoid N+1 queries
- [ ] Proper error handling
- [ ] Transaction usage when needed

### Before UI Components
- [ ] Null/undefined checks before rendering
- [ ] Loading states handled
- [ ] Error boundaries implemented
- [ ] Proper TypeScript prop types

## ğŸ”§ Development Workflow

1. **Start with search**: Look for similar patterns in bug database
2. **Copy working patterns**: Don't recreate solutions
3. **Follow prevention checklists**: Based on component type
4. **Test immediately**: Verify no regressions
5. **Update bug database**: If you find new patterns

## ğŸ“ Learning from Bugs

When you encounter a bug:
- **Document it immediately** using the template
- **Add searchable tags** for future reference
- **Include prevention steps** to avoid recurrence
- **Update relevant checklists** with new learnings

Remember: **The goal is to never solve the same bug twice**. Always check the bug database first!

---

*This rule ensures AI development follows established patterns and prevents recurring bugs.*
